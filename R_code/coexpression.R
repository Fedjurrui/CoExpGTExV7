

# TODO: Add comment
# 
# Author: juanbot
###############################################################################

library(preprocessCore)
#library(limma)
library(stringr)
library(swamp)
library(sva)
library(gplots)
library(outliers)
library(WGCNA)
require(flashClust)
require(gProfileR)
require(GOSim)


source("coexpinit.R")
source("naming.R")
source("netdb.R")
source("geneannot.R")

k.means.min.genes.to.consider.grey = 200
gdp.coexp = function(){
  return("/Users/federico/OneDrive/coexp")
}
gdp.rosmap = function(){
  return(paste0(gdp.coexp(),"/examples/"))
}

coexp.plotMDS = function(rpkms.net,path,covvars,label,n.mds=-1){
	covs = coexp.getCovariates()
	intersect.s = intersect(rownames(covs),colnames(rpkms.net))
	covs = covs[intersect.s,]
	rpkms.net = rpkms.net[,intersect.s]
	stopifnot(identical(colnames(rpkms.net),rownames(covs)))
	
	#Each covariate has a name equal to a column name
	#This plot is useful to see whether the covariate has any
	#discriminatory power between their different values or, on 
	#the contrary, all samples appear mixed across values
	for(covvar in covvars){
		cat(paste0("Working on MDS plot for ",covvar,"\n"))
		pdf(paste0(path,covvar,".pdf"),height=8,width=30)
		if(n.mds > 0)
			mask = sample(ncol(rpkms.net),n.mds)
		else
			mask = c(1:ncol(rpkms.net))
		colors = rainbow(length(levels(covs[,covvar])))
		plotMDS(rpkms.net[,mask],col=colors[as.numeric(covs[,covvar])],
				main=paste0("MDS using ",covvar," ",label))
		legend("topright",fill=colors,
				legend=levels(covs[,covvar]))
		dev.off()
	}
	
}

coexp.getDownstreamNetwork = function(tissue="mytissue",
		n.iterations=50,	#Number of iterations for k-means, 50 recommended
		expr.data, 	#We expect a file name pointing to a dataframe (RDS format) with 
		#genes in columns and samples in rows. Each gene name appears 
		#in the column name. Better to use gene symbols as names
		beta=-1,	#If -1 the algorithm will seek for the best beta
		job.path="~/tmp/",	#Where to store all results
		min.cluster.size=30,		#Minimum number of genes to form a cluster
		net.type="signed",			#Leave it like that (see WGCNA docs)
		debug=F
){
	
	final.net=NULL
	save.tom=F
	distance.type="cor"
	centroid.type="pca"
	cor.type="pearson"
	
	if(debug){
		if(typeof(expr.data) == "character")
			expr.data = readRDS(expr.data)
		expr.data = expr.data[,1:1500]
		n.iterations=5
	}
	
	
	
	net.and.tom = coexp.getAndPlotNetworkLong(expr.data=expr.data,
			beta=beta,
			tissue.name=tissue,
			min.cluster.size=min.cluster.size,
			save.plots=TRUE,
			additional.prefix=job.path,
			return.tom=TRUE,
			cor.type=cor.type)
	
	if(is.null(final.net))
		final.net = paste0(job.path,"/","net",tissue,".",
				net.and.tom$net$beta,".it.",n.iterations,".rds")
	
	if(save.tom)
		saveRDS(net.and.tom$tom,paste0(final.net,".tom.rds"))
	
	outnet = coexp.applyKMeans(tissue=tissue,
			n.iterations=n.iterations,
			net.file=net.and.tom$net,
			distance.type=distance.type,
			centroid.type=centroid.type,
			tom=net.and.tom$tom,
			expr.data=expr.data,
			plot.evolution=plot.evolution,
			beta=net.and.tom$net$beta,
			job.path=job.path,
			final.net=final.net,
			cor.type=cor.type)
	
	outnet$beta = net.and.tom$net$beta
	outnet$type = net.and.tom$net$type
	outnet$net = outnet[[1]]
	
	cat("Generating mod sizes for",final.net,"\n")
	pdf(paste0(final.net,".mod_size.pdf"))
	coexp.plotModSizes(which.one="new",tissue=final.net)
	dev.off()
	pdf(paste0(final.net,".Eigengenes_clustering.pdf"))
	coexp.plotEGClustering(which.one="new",tissue=final.net)
	dev.off()
	return(outnet)
}

coexp.plotEGClustering = function(tissue,which.one){
	net = coexp.getNetworkFromTissue(tissue=tissue,which.one=which.one)
	# Calculate dissimilarity of module eigengenes
	MEDiss = 1-cor(net$MEs)
	# Cluster module eigengenes
	METree = flashClust(as.dist(MEDiss), method = "average")
	
	MEDissThres = 0.1 #### MERGING THRESHOLD
	# Call an automatic merging function
	
	# Plot the result
	tb = table(net$moduleColors)
	names(tb) = paste0("ME",names(tb))
	tb <- tb[ METree$labels ]
	METree$labels <- paste0(names(tb), ":", tb)
	
	plot(METree, main = paste0("Eigengenes:",tissue," from ",which.one),
	     xlab=paste0("Modules in ",tissue," from ",which.one))
}

coexp.getExchangedGenes <- function(old.partition,new.partition){
	return(old.partition[old.partition != new.partition])
}

#Arguments
#
#n.module				number of genes within the module
#n.module.and.specific	number of genes within module and with the condition (e.g. TFs, external list...)
#total.specific			number of genes in the global condition list
#total.net				number of genes in the network

coexp.testGeneSet = function(n.module,n.module.and.specific,total.specific,total.net,test="fisher",oldform=F){
	stopifnot(test == "fisher" | test == "chi")
	vector.data = matrix(ncol=2,nrow=2)
	
	vector.data[1,1] = n.module.and.specific
	vector.data[1,2] = n.module - n.module.and.specific
	vector.data[2,1] = total.specific - vector.data[1,1]
	if(oldform)
		vector.data[2,2] = total.net - n.module - total.specific
	else
		vector.data[2,2] = total.net - vector.data[1,2] - vector.data[2,1] - vector.data[1,1]
	#print(vector.data)
	if(test == "fisher")
		test.result = fisher.test(vector.data,alternative="greater")
	else if(test == "chi")
		test.result = chisq.test(vector.data)
	return(test.result)
}


coexp.plotModSizes = function(which.one,tissue){
	
  net = coexp.getNetworkFromTissue(tissue=tissue,which.one=which.one)
  tb2 <- table(net$moduleColors)[order(table(net$moduleColors))] 
	barplot.title <- paste0("Module sizes for ",length(unique(net$moduleColors)), 
			" modules and ",tissue)
	barplot(tb2,col=names(tb2),
			main=barplot.title,
			ylab="Mod size",las=2)
}

coexp.generateBetaStudy <- function(expr.data,powers=c(1:30),title=NULL,plot.file=NULL,
		net.type="signed",cor.type="pearson"){
	stopifnot(cor.type == "pearson" | cor.type == "spearman")
	if(!is.null(plot.file))
		pdf(plot.file,width=18,height=8)
	
	old.par <- par()
	
	if(cor.type == "pearson")
		sft = pickSoftThreshold(expr.data,powerVector=powers,verbose=5,moreNetworkConcepts=TRUE,
				networkType=net.type,corOptions=list(use='p'))
	else
		sft = pickSoftThreshold(expr.data,powerVector=powers,verbose=5,moreNetworkConcepts=TRUE,
				networkType=net.type,corFn=stats::cor,corOptions=list(method = "spearman"))
	
	par(mfrow=c(1,2))
	cex1=0.9
	#Plotting the adjustment level 
	
	plot(sft$fitIndices[,1],-sign(sft$fitIndices[,3])*sft$fitIndices[,2],
			xlab=paste0("Soft threshold, cor type ",cor.type," net type ",net.type),
			ylab="Scale Free Topology Model Fit.R^2",type="n",
			main=paste0("Scale independence ",title))
	
	text(sft$fitIndices[,1],-sign(sft$fitIndices[,3])*sft$fitIndices[,2],
			labels=powers,col="red",cex=cex1)
	
	abline(h=0.80,col="red",lwd=2)
	
	
	#Plotting mean network connectivity
	plot(sft$fitIndices[,1],sft$fitIndices[,5],xlab="Soft Threshold",
			ylab="Mean Connectivity", type="n", main=paste0("Mean connectivity (cor type ",cor.type,"net type  ",
					net.type,") ",title))
	text(sft$fitIndices[,1],sft$fitIndices[,5],labels=powers,col="red",
			cex=cex1)
	
	par(old.par)
	if(!is.null(plot.file)){
		dev.off()
		write.csv(sft$fitIndices,paste0(plot.file,".csv"))
	}
	
	sft
}

coexp.applyKMeans <- function(tissue="SNIG.Peer4.Beta6",
		create.tom=TRUE,
		distance.type=COR_DISTANCE,
		centroid.type=EG_CENTROID,
		n.iterations=20,
		net.file=snig.net.file,
		expr.data=snig.expr.data.object,
		beta=6,
		tom=NULL,	#If TOM is NULL, it is created. If it is an object is used and if its a character is readed
		job.path="/tmp/kmeans/",
		plot.evolution=TRUE,
		plot.go=FALSE,
		debug=F,
		n.debug=500,
		norm.when.euc.mean=TRUE,
		net.type="signed",
		min.exchanged.genes=20,
		final.net=paste0(job.path,"/","net",tissue,".",beta,".",net.type,".it.",n.iterations,".rds"),
		cor.type="pearson"){
	
	print("Expression data")
	if(typeof(expr.data) == "character")
		expr.data <- readRDS(expr.data)
	print(expr.data[1:5,1:5])
	
	if(debug){
		cat("We are debugging, using only ",n.debug," genes")
		expr.data = expr.data[,1:n.debug]
	}
	
	#Step 2
	if(typeof(net.file) == "character"){
		print("Loading network")
		net <- readRDS(net.file)
	}else
		net = net.file
	
	if(debug){
		net$moduleColors = net$moduleColors[1:n.debug]
	}
	
	if(is.null(tom)){
		#Now we create the TOM
		if(cor.type == "spearman")
			corOptions = "use = 'p', method = 'spearman'"
		else
			corOptions = "use = 'p'"
		adjacency = adjacency(expr.data, power = beta, type = net.type, corOptions=corOptions)
		tom.matrix = TOMsimilarity(adjacency) 
		cat("The tom matrix has been generated\n")
	}else if(typeof(tom) == "character"){
		cat("TOM matrix loaded from file",tom,"\n")
		tom.matrix = readRDS(tom)
	}else{
		cat("TOM matrix passed as argument\n")
		tom.matrix = tom
	}
	
	print(tom.matrix[1:5,1:5])	
	
	plot.evolution.file <- paste0(final.net,"_",distance.type,"_",centroid.type,"_evolution.kmeans.pdf")
	partitions.file <- paste0(final.net,"_",distance.type,"_",centroid.type,"_partitions.rds")
	evolution.file <- paste0(final.net,"_",distance.type,"_",centroid.type,"_evolution.kmeans.rds")
	print(paste0("Evolution plot will be at ",plot.evolution.file))
	print(paste0("Partitions data will be at ",partitions.file))
	print(paste0("Evolution data will be at ",evolution.file))
	
	#if(do.go){
	go.file <- paste0(final.net,"_",distance.type,"_",centroid.type,"_go.rds")
	print(paste0("GO analysis will be at  ",go.file))
	#}
	
	
	#ALGORITHM SPECIFICATION
	#Step 1. Let D be the expression data in which dij in D represents the expression value for
	#sample i and gene j, being s samples and g genes in total.
	#Step 2. Construct the partition by the WGCNA process, let P_D={m_1, m_2, ..., m_n} be
	#that partition where m_k is the k-th module.
	#Step 3. Get the eigengenes for each module within the partition, E={e_1, e_2, ..., e_n}
	#Step 4. Set up the k-means clustering
	#Step 4.1. Set k to n
	#Step 4.2. Set the centroids C to the eigengenes E, thus C to E
	#Step 5. Run the algorithm and monitor its evolution
	#Step 5.1 Set iterations to 0
	#Step 5.2 Create a new partition P', given C with n modules such that, for each gene, 1 <=
	#		j <= g, g_j belongs to the module c_t in C such that a distance meassure d(g_j,c_t) is
	#		minimum.
	#		Step 5.3 Calculate eigengenes of P', giving a new E'
	#		Step 5.4 Evaluate the progress. If progress done, set iterations to iterations + 1 and
	#		C to E' and go to step 5.2
	#Step 5.5 Finish
	#
	
	
	##Step 1.
	
	#Gather the current partition we start from
	partition.in.colors <- net$moduleColors
	print(head(partition.in.colors,5))
	
	#Step 3
	
	print("Getting initial eigengenes")
	if(sum(partition.in.colors == "grey") < k.means.min.genes.to.consider.grey)
		eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)
	else
		eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)
	
	print(paste0("We got ",length(eigengenes$eigengenes), " eigengene vectors"))
	print(head(eigengenes$eigengenes))
	
	#This variable is fixed and used as a reference to indicate the
	#modules used (they are colours but the position within the vector is
	#also relevant)
	centroid.labels <- substring(names(eigengenes$eigengenes),3)
	print("Module colors are")
	print(head(centroid.labels))
	
	#Step 4
	k <- length(eigengenes$eigengenes)
	#Centroids must be a matrix with as much colums as centroids, 
	#as much rows as samples
	centroids <- coexp.createCentroidMatrix(eigengenes$eigengenes)
	
	
	
	print("We have generated centroids")
	print(head(centroids))
	
	
	#Step 5
	#For storage of all the partitions created during the iterations
	partitions <- list()
	#A partition will be a list of as much elements as genes and for the
	#i-th position it stores the index of the module the ith gene belongs
	#to, and the color can be found in "centroid.labels"
	print("From partition ")
	print(head(partition.in.colors))
	print("We create ")
	new.partition <- match(partition.in.colors, centroid.labels)
	print(head(new.partition))
	names(new.partition) <- centroid.labels[new.partition]
	partitions[[1]] <- new.partition
	
	#kmeans.evolution <- list()
	#kIMs <- getkIMs(tom.matrix,new.partition,length(centroid.labels))
	#kIMsWGCNA <- getkIMsFromWGCNA(expr.data,partition.in.colors,beta)
	#kMEs <- getkMEs(expr.data,new.partition,centroids)
	#kmeans.evolution[[1]] <- list(exchanged.genes=0,kMEs=kMEs,kIMs=kIMsWGCNA)
	
	#Launch the iterations
	#min.exchanged.genes = 20
	exchanged.genes = min.exchanged.genes + 1
	iteration = 1
	
	while(exchanged.genes > min.exchanged.genes & iteration <= n.iterations){
		
		#for(iteration in 1:n.iterations){
		print(paste0("Starting partition ",iteration))	
		print(paste0("Number of centroids before getting new partition ",ncol(centroids)))  
		
		new.partition <- apply(expr.data,MARGIN=2,coexp.getBestModuleCor,centroids=centroids,
				signed=(net.type == "signed"),cor.type=cor.type)
		
		print(paste0("We got a new partition with distance type ",distance.type))
		
		partitions[[iteration + 1]] <- new.partition
		#Get the control values for the new partition
		exchanged.gene.count <- length(coexp.getExchangedGenes(partitions[[iteration]],
						partitions[[iteration + 1]]))
		print(paste0("A total of ", exchanged.gene.count, 
						" genes have moved to another partition"))
		#print(new.partition)
		new.partition.in.colors <- centroid.labels[unlist(new.partition)]
		print("New partition colors")
		print(head(new.partition.in.colors))
		centroids <- coexp.getNewCentroids(expr.data,new.partition.in.colors,centroid.labels,centroid.type)
		#centroids <- unlist(centroids)
		
		exchanged.genes = exchanged.gene.count
		iteration = iteration + 1
	}
	cat("We finish with",iteration,"iterations\n")
	cat("Last number of gene changes where",exchanged.genes,"\n")
	saveRDS(partitions,partitions.file)
	
	print("The algorithm finished correctly")
	result.net = coexp.genNetFromPartition(expr.data.file=expr.data,
			beta=beta,partitions.file=partitions.file,index=-1)
	if(typeof(final.net) == "character"){
		saveRDS(result.net,final.net)
		cat("Final network saved at",final.net,"\n")
		return(final.net)
	}
	return(result.net)
}

coexp.getNewCentroids <- function(expr.data,partition.in.colors,centroid.labels,centroid.type=MEAN_CENTROID){
	print(paste0("Generating centroids with ",centroid.type))
	
	
	return(coexp.getNewCentroidsEG(expr.data,partition.in.colors,centroid.labels))
	print(paste0("Centroid type ",centroid.type, " unknown. Returning NULL"))
	return(NULL)
}

coexp.getNewCentroidsEG = function(expr.data,partition.in.colors,centroid.labels){
	#if(sum(partition.in.colors == "grey") < k.means.min.genes.to.consider.grey)
	#	eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)$eigengenes
	#else
	eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)$eigengenes
	
	names(eg.vectors) <- substring(names(eg.vectors),3)
	eg.vectors <- eg.vectors[,centroid.labels]
	return(eg.vectors)
}

coexp.genNetFromPartition = function(expr.data.file=snig.expr.data.object,beta=6,
		partitions.file="/tmp/kmeans/partitions_SNIG.Peer4.Beta6.rds",index=-1){
	
	parts = readRDS(partitions.file)
	
	if(index < 0)
		index = length(parts)
	
	colors = unique(names(parts[[1]]))
	col.number = unique(parts[[1]])
	
	if(typeof(expr.data.file) == "character")
		expr.data = readRDS(expr.data.file)
	else
		expr.data = expr.data.file
	
	#if(typeof(net.file) == "character")
	#	net = readRDS(net.file)
	#else
	#	net = net.file
	new.net <- NULL
	if(index == 1){
		new.net$moduleLabels = parts[[index]]
		new.net$moduleColors = names(parts[[index]])
		names(new.net$moduleColors) = colnames(expr.data)
		names(new.net$moduleLabels) = colnames(expr.data)
		
	}else{
		new.net$moduleLabels = parts[[index]]
		new.net$moduleColors = colors[match(parts[[index]],col.number)]
		names(new.net$moduleColors) = colnames(expr.data)
		names(new.net$moduleLabels) = colnames(expr.data)
		
	}
	
	#If there are some grey genes as NA, add them again
	new.net$moduleColors[is.na(new.net$moduleColors)] = "grey"
	
	if(sum(new.net$moduleColors == "grey") >= k.means.min.genes.to.consider.grey)	
		new.net$MEs  = moduleEigengenes(expr.data,new.net$moduleColors,softPower=beta, excludeGrey=F)$eigengenes
	else
		new.net$MEs  = moduleEigengenes(expr.data,new.net$moduleColors,softPower=beta, excludeGrey=T)$eigengenes
	return(new.net)
}

coexp.getBestModuleCor = function(gene,centroids,signed=TRUE,cor.type){
	
	return(which.max(coexp.corDistance(a=centroids,b=gene,signed=signed,cor.type=cor.type)))
}

coexp.createCentroidMatrix <- function(eigengenes){
	my.matrix <- NULL
	for(eigengene in eigengenes){
		my.matrix <- cbind(my.matrix,eigengene)
	}
	return(my.matrix)
}

coexp.getAndPlotNetworkLong <- function(expr.data,beta,net.type="signed",
		tissue.name="SNIG",title=NULL,
		additional.prefix=NULL,
		min.cluster.size=100,
		save.plots=TRUE,
		return.tom=FALSE,
		max.k.cutoff = 150,
		r.sq.cutoff = 0.8,
		cor.type="pearson"){
	
	net <- NULL
	
	if(typeof(expr.data) == "character"){
		print(paste0("Reading expression from ",expr.data))
		expr.data = readRDS(expr.data)
	}
	
	print(paste0("We called getAndPlotNetworkLong with ",ncol(expr.data),
					" genes and ",nrow(expr.data)," samples and beta ",beta, 
					" and correlation type ",cor.type,
					" and network type ", net.type," and min.cluster.size ", 
					min.cluster.size, " for tissue ",tissue.name))
	
	print(paste0("Expression data is the following within getAndPlotNetworkLong"))
	print(expr.data[1:5,1:5])
	
	#We assume gene names are at columns
	gene.names <- colnames(expr.data)
	sample.names <- rownames(expr.data)
	#Lets delete unused memory
	print("Garbage collecting")
	gc()
	
	#If beta < 0 then we have to figure out by ourselves
	if(beta < 0){
		if(save.plots){
			b.study = coexp.generateBetaStudy(expr.data,title=paste0("Beta study for ",tissue.name),
					net.type=net.type,cor.type=cor.type,
					plot.file=paste0(additional.prefix,
							"betastudy",gsub(" ","_",tissue.name),".",net.type,".pdf"))
		}else
			b.study = generateBetaStudy(expr.data,net.type=net.type,cor.type=cor.type)
		#beta = b.study$powerEstimate
		
		
		cat("Choosing beta from SFT.R.sq cut-off",r.sq.cutoff,"and max.k cut-off",max.k.cutoff,"\n")
		beta = min(b.study$fitIndices[as.numeric(b.study$fitIndices$SFT.R.sq) > r.sq.cutoff & 
								as.numeric(b.study$fitIndices$slope) < 0 &
								as.numeric(b.study$fitIndices$max.k) > max.k.cutoff,"Power"])
		
		if(beta == Inf){
			#OK, lets drop-off the maxk.cutoff
			beta = min(b.study$fitIndices[as.numeric(b.study$fitIndices$SFT.R.sq) > r.sq.cutoff &
									as.numeric(b.study$fitIndices$slope) < 0,"Power"])
		}
		
		print(paste0("The estimated beta value is ",beta))
		print(paste0("The suggested beta was ",b.study$powerEstimate))
		
		if(beta == -Inf & is.na(b.study$powerEstimate)){
			stop("There is something wrong, our beta is",beta,"and suggested is",
					b.study$powerEstimate,"\n")
		}
		
		if(is.na(b.study$powerEstimate)){
			cat("We'll use",beta,"for beta\n")
			
		}else{
			if(beta == -Inf){
				cat("We'll use WGCNA's suggested beta\n")
				beta = b.study$powerEstimate
			}else if(beta - b.study$powerEstimate > 5){
				beta = trunc(0.5*(beta + b.study$powerEstimate))
				cat("We'll use average between WGCNA's suggested beta and ours.\n")
			}	
		}
		
		if(beta == Inf){
			beta = 21
			cat("Warning, the final beta is",beta,"and SFT is compromised\n")
		}
		
		cat("The final beta value to use is:",beta,"\n")
	}
	
	additional.prefix = paste0(additional.prefix,tissue.name,".",beta)
	
	#Create the adjacency matrix of genes coming from the expression data, with the beta
	#passwd as argument
	print("Creating adjacency matrix")
	if(cor.type == "spearman")
		corOptions = "use = 'p', method = 'spearman'"
	else
		corOptions = "use = 'p'"
	
	adjacency = adjacency(expr.data, power = beta, type = net.type, corOptions = corOptions) 
	print("Created")
	print(paste0("Adjacency is the following within getAndPlotNetworkLong"))
	print(adjacency[1:5,1:5])
	# Topological Overlap Matrix (TOM)
	# Turn adjacency into topological overlap
	print("Creating TOM")
	if(net.type == "signed")
		TOM = TOMsimilarity(adjacency)
	else if(net.type == "unsigned"){
		cat("As the network type is unsigned, the TOM type we'll create is signed")
		TOM = TOMsimilarity(adjacency,TOMType="signed")
	}else{
		stop(paste0("Nework type ",net.type," unrecognized when creating the network"))
	}
	#Now we can delete adjacency
	print("Deleting adjacency matrix")
	rm(adjacency)
	dissTOM = 1-TOM
	print("Created TOM, dissTOM")
	print(dissTOM[1:5,1:5])
	
	
	
	# Clustering using TOM
	# Call the hierarchical clustering function that makes the clustering
	# dendrogram to grow until the leaves are genes
	
	geneTree = flashClust(as.dist(dissTOM), method = "average")
	
	print("Now the genetree")
	print(geneTree)
	# Dynamic Tree Cut
	# We like large modules, so we set the minimum module size relatively high
	# Module identification using dynamic tree cut
	
	n.mods = 0
	deep.split = 2
	while(n.mods < 10 & deep.split < 5){
		dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM, deepSplit = deep.split,
				pamRespectsDendro = FALSE, minClusterSize = min.cluster.size)
		n.mods = length(table(dynamicMods))
		deep.split = deep.split + 1
	}
	
	#This will print the tissue an the number of genes by module
	print(tissue.name)
	print(table(dynamicMods))
	
	# Convert numeric lables into colors
	#This will print the same, but using as label for modules the corresponding colors
	dynamicColors = labels2colors(dynamicMods)
	print(tb <- table(dynamicColors))
	names(tb) <- paste("ME", names(tb), sep="")
	
	# Calculate eigengenes
	MEList = moduleEigengenes(expr.data, colors = dynamicColors, excludeGrey=TRUE)
	MEs = MEList$eigengenes
	# Calculate dissimilarity of module eigengenes
	MEDiss = 1-cor(MEs)
	# Cluster module eigengenes
	METree = flashClust(as.dist(MEDiss), method = "average")
	
	MEDissThres = 0.1 #### MERGING THRESHOLD
	# Call an automatic merging function
	merge = mergeCloseModules(expr.data, dynamicColors, cutHeight = MEDissThres, 
			verbose = 3, unassdColor="grey",getNewUnassdME = FALSE)
	# The merged module colors
	mergedColors = merge$colors
	# Eigengenes of the new merged modules
	mergedMEs = merge$newMEs
	
	if(save.plots){
		dendro.name = paste0(additional.prefix,"_dendro_colors.pdf")
		eigengenes.name = paste0(additional.prefix,"_Eigengenes_clustering.pdf")
		
		pdf(file=dendro.name)
		plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
				c("Dynamic Tree Cut", "Merged dynamic"),dendroLabels = FALSE, 
				hang = 0.03, addGuide = TRUE,
				guideHang = 0.05,main=title)
		dev.off()
		
		pdf(file=eigengenes.name)
		# Plot the result
		tb <- tb[ METree$labels ]
		METree$labels <- paste0(names(tb), ":", tb)
		
		plot(METree, main = paste0(title," ",tissue.name,
						" Clustering of module eigengenes"), xlab = "", sub = "")
		# Plot the cut line into the dendrogram
		abline(h=MEDissThres, col = "red")
		dev.off()
	}
	#Creating the connectivity analysis
	#expr.data.sets <- NULL
	#expr.data.sets[[1]] <- expr.data
	#expr.data.sets.names <- vector(mode="character",length=1)
	#expr.data.sets.names[1] <- paste0("Tissue ",tissue.name)
	#pdf(file=paste0(additional.prefix,"_connectivity.pdf"))
	#connectivity(expr.data.sets,expr.data.sets.names,bethas=c(betha))
	#def.off()
	
	
	#Prepare for creating the network objecto to return
	# Rename to moduleColors
	moduleColors = mergedColors
	# Construct numerical labels corresponding to the colors
	colorOrder = c("grey", standardColors(400))
	moduleLabels = match(moduleColors, colorOrder)-1
	MEs = mergedMEs
	tb2 <- table(moduleColors)[order(table(moduleColors))] 
	print(tb2)
	
	if(save.plots){
		pdf(file=paste0(additional.prefix,"_mod_size.pdf"))
		barplot.title <- paste0("Mod. sizes for ",length(unique(moduleColors)), 
				" modules and ",title)
		barplot(tb2,col=names(tb2),
				main=barplot.title,
				xlab="Mod colors",ylab="Mod size")
		dev.off()
	}
	
	net$MEs <- MEs
	rownames(net$MEs) <- sample.names
	net$moduleLabels <- moduleLabels
	net$moduleColors <- moduleColors
	net$beta = beta
	net$type = net.type
	names(net$moduleColors) <- gene.names
	net$geneTree <- geneTree	
	if(return.tom){
		return(list(net=net,tom=TOM))
	}else
		return(net)
}

coexp.corDistance = function(a,b,signed=TRUE,cor.type="pearson"){
	if(cor.type=="pearson"){
		if(signed)
			#return(0.5 + 0.5*WGCNA::corFast(a,b)) (Note they are equivalent)
			return(0.5 * (1 + WGCNA::corFast(a,b)))
		return(abs(WGCNA::corFast(a,b)))
	}else{
		if(signed)
			#return(0.5 + 0.5*WGCNA::corFast(a,b)) (Note they are equivalent)
			return(0.5 * (1 + stats::cor(a,b,method=cor.type)))
		return(abs(stats::cor(a,b,method=cor.type)))
	}
}

coexp.corDistance = function(a,b,signed=TRUE,cor.type="pearson"){
  if(cor.type=="pearson"){
    if(signed)
      #return(0.5 + 0.5*WGCNA::corFast(a,b)) (Note they are equivalent)
      return(0.5 * (1 + stats::cor(a,b)))
    return(abs(stats::cor(a,b)))
  }else{
    if(signed)
      #return(0.5 + 0.5*WGCNA::corFast(a,b)) (Note they are equivalent)
      return(0.5 * (1 + stats::cor(a,b,method=cor.type)))
    return(abs(stats::cor(a,b,method=cor.type)))
  }
}

coexp.getMM = function(net=NULL,
		expr.data.file=NULL,
		tissue,genes,
		table.format=FALSE,
		which.one="rnaseq",
		silent=F,keep.grey=F,
		alt.gene.index=NULL){
	
		net = coexp.getNetworkFromTissue(tissue,which.one)
		if(is.null(expr.data.file))
	  	expr.data = coexp.getExprDataFromTissue(tissue,which.one)
		else
		  expr.data = readRDS(expr.data.file)
		if(which.one == "micro19K"){
			names(net$moduleColors) = colnames(expr.data)
		}
		
	
	mm = NULL
	
	if(is.null(genes)){
		#There is no correlation within grey module normally
		genes = names(net$moduleColors) #[net$moduleColors != "grey"]
	}
	
	if(table.format){
		out.table = data.frame(list(ensgene=character(0),name=character(0),
						module=character(0),mm=numeric(0)),stringsAsFactors=FALSE)		
		n.row = 1
		out.table[1:length(genes),1] = genes
		out.table[1:length(genes),2] = coexp.fromAny2GeneName(genes)
		out.table[1:length(genes),3] = net$moduleColors[match(genes,names(net$moduleColors))]
	}
	
	for(gene in genes){
		if(!is.null(alt.gene.index)){
			module = net$moduleColors[alt.gene.index[which(genes %in% gene)]]
			expr.data.gene.index = alt.gene.index[which(genes %in% gene)]
		}else{
			module = net$moduleColors[names(net$moduleColors) %in% gene]
			expr.data.gene.index = gene
		}
		if(length(module) == 0){
			if(!silent)
				cat("Gene ",gene," not in network\n")
			mm[[gene]] = -1
		}else{
			if(length(module) > 1)
				module = module[1]
			if(module == "grey" & !keep.grey)
				mm[[gene]] = 0
			else{
				if(length(module) > 1){
					if(!silent)
						print(paste0("Gene ",gene, " found in modules ",module))
					module = module[1]
					if(!silent)
						print(paste0("Keeping only ",module))
				}
				
				tryCatch(mm[[gene]] <- cor(net$MEs[paste0("ME",module)],expr.data[,expr.data.gene.index]),
						error = function(e){
							print(paste0("Error in module ",module," ",e))
						})
			} 
		}
	}
	if(table.format){
		out.table[1:length(genes),4] = unlist(mm[genes])
		return(out.table)
	}
	return(mm)
	
}

coexp.getFileFromPath <- function(file.name){
	splits <- str_split(file.name,"/")
	splits <- splits[[1]]
	return(splits[length(splits)])
}

coexp.getPathFromFullName = function(file.name){
	splits <- str_split(file.name,"/")
	splits <- splits[[1]]
	path = paste0(splits[1:(length(splits)-1)],collapse="/")
	path = paste0("/",path,"/")
	return(path)
}


coexp.corWithCatTraits = function(tissue,which.one,covlist,covs=NULL){
  MEs = coexp.getNetworkEigengenes(tissue=tissue,which.one=which.one)
  if(is.null(covs))
    covs = coexp.getCovariates(tissue=tissue,which.one=which.one)
  covs = covs[,covlist]
  
  for(i in 1:ncol(covs)){
    if(typeof(covs[,i]) ==  "character")
      covs[,i] = as.factor(covs[,i])
  }
  factor.mask = NULL
  for(i in 1:ncol(covs)){
    factor.mask = c(factor.mask,is.factor(covs[,i]))
  }
  
  fcm = matrix(nrow=ncol(MEs),ncol=sum(factor.mask))
  index = 1
  for(i in which(factor.mask)){
    #cat("Factor",colnames(trait.data)[i],"\n")
    #cat("Levels",levels(trait.data[,i]))
    #print(trait.data[,i])
    for(j in 1:ncol(MEs)){
      #print(paste0(i,j)
      if(length(unique(covs[,i])) > 1){
        form = eg ~ cov
        data.in = data.frame(MEs[,j],covs[,i])
        colnames(data.in) = c("eg","cov")
        fcm[j,index] = anova(aov(form,data.in))$`Pr(>F)`[1]
      }else
        fcm[j,index] = 1
      
    }	
    fcm[,index] = p.adjust(fcm[,index],method="BH")
    index = index + 1
  }
  
  moduleTraitCor = cor(MEs,covs[,!factor.mask],use="p")
  
  #Generate the p-values for significance of a given matrix of correlations, for all modules,
  #between traits data and eigengenes, both from samples
  moduleTraitPvalue = corPvalueStudent(moduleTraitCor,nrow(MEs))
  moduleTraitPvalue = cbind(moduleTraitPvalue,fcm)
  colnames(moduleTraitPvalue) = c(colnames(covs)[!factor.mask],
                                  colnames(covs)[factor.mask])
  moduleTraitPvalue = -log10(moduleTraitPvalue)
  moduleTraitPvalue[moduleTraitPvalue > 10] = 10
  labeledHeatmap(Matrix=moduleTraitPvalue,
                 xLabels=colnames(moduleTraitPvalue),
                 yLabels=gsub("ME","",names(MEs)),
                 ySymbols=names(MEs),
                 colorLabels=FALSE,
                 colors=rev(heat.colors(50)),
                 cex.text=0.5,
                 zlim = c(0,10),
                 main="Module-trait relationships")
}
  

coexp.corWithNumTraits = function(tissue,which.one,covlist,covs=NULL){
  MEs = coexp.getNetworkEigengenes(tissue=tissue,which.one=which.one)
  if(is.null(covs))
    covs = coexp.getCovariates(tissue=tissue,which.one=which.one)
  covs = covs[,covlist]
  moduleTraitCor = cor(MEs, covs, use = "p")
  moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nrow(MEs))
  textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                     signif(moduleTraitPvalue, 1), ")", sep = "")
  dim(textMatrix) = dim(moduleTraitCor)
  par(mar = c(6, 8.5, 3, 3));
  # Display the correlation values within a heatmap plot
  labeledHeatmap(Matrix = moduleTraitCor,
                 xLabels = covlist,
                 yLabels = names(MEs),
                 ySymbols = names(MEs),
                 colorLabels = FALSE,
                 colors = blueWhiteRed(50),
                 textMatrix = textMatrix,
                 setStdMargins = FALSE,
                 cex.text = 0.5,
                 zlim = c(-1,1),
                 main = paste0("Module-trait relationships"))
}


coexp.trasposeDataFrame = function(file.in,first.c.is.name=T){
  if(typeof(file.in) == "character")
    data.in = readRDS(file.in)
  else{
    data.in = file.in
    rm(file.in)
  }
  
  if(first.c.is.name){
    data.t = as.data.frame(cbind(apply(data.in[,-1],MARGIN=1,function(x){ return(as.numeric(x))})))
    colnames(data.t) = data.in[,1]
    rownames(data.t) = colnames(data.in[-1])
  }else{
    data.t = as.data.frame(cbind(apply(data.in,MARGIN=1,function(x){ return(as.numeric(x))})))
    colnames(data.t) = rownames(data.in)
    rownames(data.t) = colnames(data.in)	
  }
  return(data.t)
}

